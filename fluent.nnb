{
    "cells": [
        {
            "language": "typescript",
            "source": [
                "import EventEmitter, { on } from \"node:events\";\n\nconst isFunc = (obj: any) =>\n  typeof obj === \"function\" || obj instanceof Runnable;\n\ntype Step = {\n  step: any;\n  type: string;\n  fnc?: Function;\n};\n\ntype IteratorFunction = {\n  next: () => { value: Step; done: boolean } | { value: null; done: true };\n};\n\ntype RunnableParams = {\n  emitter?: EventEmitter;\n  emitEnd?: boolean;\n};\n\nclass Runnable {\n  name?: string;\n  state: object;\n  emitter: EventEmitter;\n  steps: Step[] = [];\n  iterator: IteratorFunction;\n  emitEnd: boolean = true;\n\n  constructor(state: object, name?: string, params: RunnableParams = {}) {\n    this.name = name;\n    this.state = state;\n    this.emitter = params.emitter ?? new EventEmitter();\n    this.emitEnd = params.emitEnd ?? true;\n\n    return this;\n  }\n\n  on(event: string | symbol, fnc: any): Runnable {\n    this.emitter.on(event, fnc);\n    return this;\n  }\n\n  emit(event: string | symbol, ...args: any[]): boolean {\n    return this.emitter.emit(event, ...args);\n  }\n\n  pipe(fnc: Function | Runnable): Runnable {\n    this.steps.push({ step: fnc, type: \"pipe\" });\n    return this;\n  }\n\n  assign(key: string | object, fnc?: Function): Runnable {\n    this.steps.push({ step: key, type: \"assign\", fnc: fnc });\n    return this;\n  }\n\n  passThrough(fnc: Function): Runnable {\n    this.steps.push({ step: fnc, type: \"passThrough\" });\n    return this;\n  }\n\n  pick(keys: string | string[]): Runnable {\n    this.steps.push({ step: keys, type: \"pick\" });\n    return this;\n  }\n\n  rooter(fnc: Function): Runnable {\n    this.steps.push({ step: fnc, type: \"rooter\" });\n    return this;\n  }\n\n  private async _exec(fnc: any) {\n    const stato = structuredClone(this.state);\n    return fnc instanceof Runnable\n      ? await fnc.run(stato, { emitter: this.emitter, emitEnd: false })\n      : await fnc(stato, this.emitter);\n  }\n\n  private async _pipe(fnc: any): Promise<Runnable> {\n    this.state = { ...this.state, ...(await this._exec(fnc)) };\n\n    return this;\n  }\n\n  private _pick(keys: string | string[]): Runnable {\n    if (!Array.isArray(keys)) keys = [keys];\n    const obj = {};\n    keys.forEach((key) => {\n      obj[key] = this.state[key];\n    });\n    this.state = obj;\n\n    return this;\n  }\n\n  private async _passThrough(fnc: Function): Promise<Runnable> {\n    await fnc(structuredClone(this.state), this.emitter);\n    return this;\n  }\n\n  private async _assign(\n    key: string | object,\n    fnc?: Function\n  ): Promise<Runnable> {\n    if (typeof key === \"string\" && !fnc) {\n      throw new Error(\"Function is required\");\n    }\n\n    if (typeof key === \"string\" && fnc) {\n      this.state[key] = await this._exec(fnc);\n    } else {\n      const execs: Promise<any>[] = [];\n      const keys: any[] = [];\n      for (const [k, objFnc] of Object.entries(key)) {\n        keys.push(k);\n        if (isFunc(objFnc)) execs.push(this._exec(objFnc));\n        else execs.push(Promise.resolve(objFnc));\n      }\n      const values = await Promise.all(execs);\n\n      for (let i = 0, length = keys.length; i < length; i++) {\n        this.state[keys[i]] = values[i];\n      }\n    }\n\n    return this;\n  }\n\n  stepsIterator(): IteratorFunction {\n    let nextIndex = 0;\n    let end = this.steps.length;\n    const step = 1;\n    return {\n      next: () => {\n        const type = this.steps[nextIndex]?.type;\n        this.emit(\"step\", {\n          id: nextIndex + 1,\n          step: type ? \"step\" : \"end\",\n          type,\n          total: end,\n          name: this.name,\n          state: this.state\n        });\n\n        if (nextIndex < end) {\n          const result = { value: this.steps[nextIndex], done: false };\n          nextIndex += step;\n          return result;\n        }\n        return { value: null, done: true };\n      }\n    };\n  }\n\n  async iterate(iteration: any) {\n    if (!iteration.done) {\n      const { step, type, fnc } = iteration.value;\n      switch (type) {\n        case \"pipe\":\n          await this._pipe(step);\n          break;\n        case \"assign\":\n          await this._assign(step, fnc);\n          break;\n        case \"passThrough\":\n          await this._passThrough(step);\n          break;\n        case \"pick\":\n          await this._pick(step);\n          break;\n      }\n      this.emit(\"step\", this.state);\n\n      await this.iterate(this.iterator.next());\n    }\n  }\n\n  private _warm(state?: object, params: RunnableParams = {}) {\n    if (state) this.state = { ...this.state, ...state };\n    if (params.emitter) this.emitter = params.emitter;\n    if (params.emitEnd !== undefined) this.emitEnd = params.emitEnd;\n\n    this.iterator = this.stepsIterator();\n  }\n\n  async run(state?: object, params: RunnableParams = {}) {\n    this._warm(state, params);\n    await this.iterate(this.iterator.next());\n\n    return this.state;\n  }\n\n  async *stream(state?: object, params: RunnableParams = {}) {\n    this._warm(state, params);\n    this.iterate(this.iterator.next());\n\n    for await (const [iteration] of on(this.emitter, \"step\")) {\n      console.log(\"*\", iteration);\n      yield iteration;\n      if (iteration.step === \"end\") break;\n    }\n\n    return this.state;\n  }\n\n  static from(steps: any[], name?: string) {\n    const r = new Runnable({}, name);\n    for (const step of steps) {\n      if (isFunc(step)) r.pipe(step);\n      if (typeof step === \"object\") r.assign(step);\n    }\n    return r;\n  }\n\n  static init(\n    state: object = {},\n    name?: string,\n    params: { emitter?: EventEmitter } = {}\n  ) {\n    return new Runnable(state, name, params);\n  }\n}\n\nconst sub = Runnable.from(\n  [\n    { k: async () => \"O\", j: 1 },\n    async (state: any) => {\n      state.y = \"ciao\";\n      return state;\n    }\n  ],\n  \"sub:seq\"\n);\n\nconst main = Runnable.init({ a: 1 }, \"main:seq\")\n  .assign({ b: async () => await 2 })\n  .passThrough((state: any, emitter: EventEmitter) => {\n    if (state.a === 1) emitter.emit(\"check\", \"a is ok\");\n  })\n  .pipe(async (state: any) => {\n    state.c = 3;\n    return state;\n  })\n  .pipe(sub)\n  .pick(\"j\");\n// .on(\"passThrough\", (state: any) => console.log(\"check\", state))\n// .on(\"step\", (step: object) => console.log(step))\n// .on(\"end\", (state: object, name: string) => console.log(\"end\", state, name));\n\n//const res = await main.run();\n\nconst stream = main.stream();\nfor await (const { state } of stream) {\n  console.log(state);\n}\n\nexport {};\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "* { a: 1, b: 2 }",
                                "undefined",
                                "{ a: 1, b: 2, c: 3, k: 'O', j: 1, y: 'ciao' }",
                                ""
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}